%{
// This defenition goes to class GPPGParser, which is a parser, that generated by gppg system
    public MainProgramNode root; // Syntax tree root 
    public Parser(AbstractScanner<ValueType, LexLocation> scanner) : base(scanner) { }
%}

%output = SimpleYacc.cs

%union { 
			public bool bVal;
			public double dVal; 
			public int iVal; 
			public string sVal; 
			public Node nVal;
			public ExprNode eVal;
			public StatementNode stVal;
			public BlockNode blVal;
			public FunHeader fHead;
			public Arguments args;
			public List<ExprNode> eList;
       }

%using ProgramTree;

%namespace SimpleParser

%token BEGIN END CYCLE ASSIGN SEMICOLON PLUS MINUS LEFT_BRACKET RIGHT_BRACKET DIV MULT VAR COLON COMMA RETURN GT LT EQ NEQ GET LET AND OR NOT IF ELSE
%token <iVal> INUM 
%token <dVal> DNUM 
%token <bVal> BVAL
%token <sVal> ID

%type <eVal> expr ident term factor function fun_list fun_call b_expr b_term b_factor not_factor relation
%type <stVal> assign statement cycle decl return cond proc
%type <blVal> stlist block
%type <fHead> fun_header
%type <args> arguments
%type <eList> expr_list

%%

progr    : fun_list { root = $1 as MainProgramNode; }
		 ;

fun_list : function { $$ = new MainProgramNode($1 as FunNode); }
		 | fun_list function { ($1 as MainProgramNode).Add($2 as FunNode); $$ = $1; }
		 ;

function : fun_header block { $$ = new FunNode($1, $2); }
		 ;

fun_header: ID ID LEFT_BRACKET arguments RIGHT_BRACKET { $$ = new FunHeader($1, $2, $4); }
		  | ID ID LEFT_BRACKET RIGHT_BRACKET { $$ = new FunHeader($1, $2, null); }
		  ;

arguments: ID ID { $$ = new Arguments($1, $2); }
		 | arguments COMMA ID ID  
			{
			  $1.Add($3,$4);
			  $$ = $1; 
			}
		 ;

stlist	 : statement 
			{ 
				$$ = new BlockNode($1); 
			}
		 | stlist statement 
			{ 
				if ($2 != null)
				{
					$1.Add($2);
			    }
				$$ = $1; 
			}
		 ;

statement: assign           { $$ = $1; }
		| cond				{ $$ = $1; }
		| decl				{ $$ = $1; }
		| block				{ $$ = $1; }
		| cycle				{ $$ = $1; }
		| return            { $$ = $1; }
		| proc				{ $$ = $1; }
		| SEMICOLON         { $$ = null; }
		;

proc	: fun_call SEMICOLON { $$ = new ProcCallNode($1 as FunCallNode); }
		;

decl	: ID ID SEMICOLON { $$ = new DeclNode($1, $2); }
		;

fun_call: ID LEFT_BRACKET expr_list RIGHT_BRACKET { $$ = new FunCallNode($1, $3); }
		| ID LEFT_BRACKET RIGHT_BRACKET { $$ = new FunCallNode($1); }
		;

expr_list: b_expr { $$ = new List<ExprNode>();
					$$.Add($1); }
		 | expr_list COMMA b_expr 
			{
			  $1.Add($3);
			  $$ = $1; 
			}
		 ;

ident 	: ID { $$ = new IdNode($1); }	
		;
	
assign 	: ident ASSIGN b_expr SEMICOLON { $$ = new AssignNode($1 as IdNode, $3); }
		;

cond	: IF LEFT_BRACKET b_expr RIGHT_BRACKET statement ELSE statement { $$ = new CondNode($3, $5, $7); }
		| IF LEFT_BRACKET b_expr RIGHT_BRACKET statement { $$ = new CondNode($3, $5, null); }
		;

b_expr	: b_expr OR b_term { $$ = new BinExprNode($1, $3, OpType.Or); }
		| b_term { $$ = $1; }
		;

b_term	: b_term AND not_factor { $$ = new BinExprNode($1, $3, OpType.And); }
		| not_factor { $$ = $1; }
		;

not_factor: b_factor { $$ = $1; }
		  | NOT b_factor { $$ = new UnExprNode($2, OpType.Not); }
		  ;

b_factor: BVAL { $$ = new BoolNode($1); }
		| relation { $$ = $1; }
		;

relation: expr GT expr { $$ = new BinExprNode($1, $3, OpType.Gt); }
		| expr LT expr { $$ = new BinExprNode($1, $3, OpType.Lt); }
		| expr LET expr { $$ = new BinExprNode($1, $3, OpType.Let); }
		| expr GET expr { $$ = new BinExprNode($1, $3, OpType.Get); }
		| expr EQ expr { $$ = new BinExprNode($1, $3, OpType.Eq); }
		| expr NEQ expr { $$ = new BinExprNode($1, $3, OpType.Neq); }
		| expr { $$ = $1; }
		;

expr	: expr PLUS term { $$ = new BinExprNode($1, $3, OpType.Plus); }
		| expr MINUS term { $$ = new BinExprNode($1, $3, OpType.Minus); }
		| term { $$ = $1; }
		;

term    : term MULT factor { $$ = new BinExprNode($1, $3, OpType.Mult); }
		| term DIV factor { $$ = new BinExprNode($1, $3, OpType.Div); }
		| factor { $$ = $1; }
		;

factor  : LEFT_BRACKET b_expr RIGHT_BRACKET { $$ = $2; }
		| ident  { $$ = $1 as IdNode; }
		| fun_call { $$ = $1 as FunCallNode; }
		| INUM { $$ = new IntNumNode($1); }
		| DNUM { $$ = new DoubleNumNode($1); }
		;

block	: BEGIN	stlist END { $$ = $2; }
		;

cycle	: CYCLE b_expr statement { $$ = new CycleNode($2, $3); }
		;

return  : RETURN b_expr SEMICOLON { $$ = new ReturnNode($2); }
		| RETURN SEMICOLON        { $$ = new ReturnNode(); }
		;
%%

