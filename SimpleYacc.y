%{
// This defenition goes to class GPPGParser, which is a parser, that generated by gppg system
    public MainProgramNode root; // Syntax tree root 
    public Parser(AbstractScanner<ValueType, LexLocation> scanner) : base(scanner) { }
%}

%output = SimpleYacc.cs

%union { 
			public bool bVal;
			public double dVal; 
			public int iVal; 
			public string sVal; 
			public Node nVal;
			public ExprNode eVal;
			public StatementNode stVal;
			public BlockNode blVal;
			public FunHeader fHead;
       }

%using ProgramTree;

%namespace SimpleParser

%token BEGIN END CYCLE ASSIGN SEMICOLON PLUS MINUS LEFT_BRACKET RIGHT_BRACKET DIV MULT VAR COLON COMMA RETURN
%token <iVal> INUM 
%token <dVal> DNUM 
%token <bVal> BVAL
%token <sVal> ID

%type <eVal> expr ident term factor function fun_list fun_call
%type <stVal> assign statement cycle decl return 
%type <blVal> stlist block
%type <fHead> fun_header

%%

progr    : fun_list { root = $1 as MainProgramNode; }
		 ;

fun_list : function { $$ = new MainProgramNode($1 as FunNode); }
		 | fun_list function { ($1 as MainProgramNode).Add($2 as FunNode); $$ = $1; }
		 ;

function : fun_header block { $$ = new FunNode($1, $2); }
		 ;

fun_header   : ID ID arguments { $$ = new FunHeader($1, $2); }
		 ;

arguments: LEFT_BRACKET arguments COMMA ID ID RIGHT_BRACKET
		 | LEFT_BRACKET ID ID RIGHT_BRACKET
		 | LEFT_BRACKET RIGHT_BRACKET
		 ;

//TODO: сделать необязательной точку с запятой после окончания блока (после '}' )
stlist	 : statement 
			{ 
				$$ = new BlockNode($1); 
			}
		 | stlist SEMICOLON statement 
			{ 
				if ($3 != null)
				{
					$1.Add($3);
			    }
				$$ = $1; 
			}
		 ;

statement: assign { $$ = $1; }
		| decl	  { $$ = $1; }
		| block   { $$ = $1; }
		| cycle   { $$ = $1; }
		| return  { $$ = $1; }
		| { $$ = null; }
	;

decl	: ID ID { $$ = new DeclNode($1, $2); }
		;

//TODO: добавить функции с аргументами
fun_call: ID arguments { $$ = new FunCallNode($1); }
		;

ident 	: ID { $$ = new IdNode($1); }	
		;
	
assign 	: ident ASSIGN expr { $$ = new AssignNode($1 as IdNode, $3); }
		;

expr	: expr PLUS term { $$ = new BinExprNode($1, $3, OpType.Plus); }
		| expr MINUS term { $$ = new BinExprNode($1, $3, OpType.Minus); }
		| term { $$ = $1; }
		;

term    : term MULT factor { $$ = new BinExprNode($1, $3, OpType.Mult); }
		| term DIV factor { $$ = new BinExprNode($1, $3, OpType.Div); }
		| factor { $$ = $1; }
		;

factor  : LEFT_BRACKET expr RIGHT_BRACKET { $$ = $2; }
		| ident  { $$ = $1 as IdNode; }
		| fun_call { $$ = $1 as FunCallNode; }
		| INUM { $$ = new IntNumNode($1); }
		| DNUM { $$ = new DoubleNumNode($1); }
		| BVAL { $$ = new BoolNode($1); }
		;

block	: BEGIN	stlist END { $$ = $2; }
		;

cycle	: CYCLE expr statement { $$ = new CycleNode($2, $3); }
		;

return  : RETURN expr { $$ = new ReturnNode($2); }
		| RETURN	  { $$ = new ReturnNode(); }
		;
%%

