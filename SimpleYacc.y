%{
// This defenition goes to class GPPGParser, which is a parser, that generated by gppg system
    public MainProgramNode root; // Syntax tree root 
    public Parser(AbstractScanner<ValueType, LexLocation> scanner) : base(scanner) { }
%}

%output = SimpleYacc.cs

%union { 
			public bool bVal;
			public double dVal; 
			public int iVal; 
			public string sVal; 
			public Node nVal;
			public ExprNode eVal;
			public StatementNode stVal;
			public BlockNode blVal;
			public FunHeader fHead;
       }

%using ProgramTree;

%namespace SimpleParser

%token BEGIN END CYCLE ASSIGN SEMICOLON PLUS MINUS LEFT_BRACKET RIGHT_BRACKET DIV MULT VAR COLON COMMA RETURN GT LT EQ NEQ GET LET AND OR NOT IF ELSE
%token <iVal> INUM 
%token <dVal> DNUM 
%token <bVal> BVAL
%token <sVal> ID

%type <eVal> expr ident term factor function fun_list fun_call b_expr b_term b_factor not_factor relation
%type <stVal> assign statement cycle decl return cond
%type <blVal> stlist block
%type <fHead> fun_header

%%

progr    : fun_list { root = $1 as MainProgramNode; }
		 ;

fun_list : function { $$ = new MainProgramNode($1 as FunNode); }
		 | fun_list function { ($1 as MainProgramNode).Add($2 as FunNode); $$ = $1; }
		 ;

function : fun_header block { $$ = new FunNode($1, $2); }
		 ;

fun_header   : ID ID arguments { $$ = new FunHeader($1, $2); }
		 ;

arguments: LEFT_BRACKET arguments COMMA ID ID RIGHT_BRACKET
		 | LEFT_BRACKET ID ID RIGHT_BRACKET
		 | LEFT_BRACKET RIGHT_BRACKET
		 ;

//TODO: сделать необязательной точку с запятой после окончания блока (после '}' )
stlist	 : statement 
			{ 
				$$ = new BlockNode($1); 
			}
		 | stlist SEMICOLON statement 
			{ 
				if ($3 != null)
				{
					$1.Add($3);
			    }
				$$ = $1; 
			}
		 ;

statement: assign { $$ = $1; }
		| cond	  { $$ = $1; }
		| decl	  { $$ = $1; }
		| block   { $$ = $1; }
		| cycle   { $$ = $1; }
		| return  { $$ = $1; }
		| { $$ = null; }
		;

decl	: ID ID { $$ = new DeclNode($1, $2); }
		;

//TODO: добавить функции с аргументами
fun_call: ID arguments { $$ = new FunCallNode($1); }
		;

ident 	: ID { $$ = new IdNode($1); }	
		;
	
assign 	: ident ASSIGN b_expr { $$ = new AssignNode($1 as IdNode, $3); }
		;

cond	: IF LEFT_BRACKET b_expr RIGHT_BRACKET statement ELSE statement { $$ = new CondNode
($3, $5, $7); }
		| IF LEFT_BRACKET b_expr RIGHT_BRACKET statement { $$ = new CondNode($3, $5, null); }
		;

b_expr	: b_expr OR b_term { $$ = new BinExprNode($1, $3, OpType.Or); }
		| b_term { $$ = $1; }
		;

b_term	: b_term AND not_factor { $$ = new BinExprNode($1, $3, OpType.And); }
		| not_factor { $$ = $1; }
		;

not_factor: b_factor { $$ = $1; }
		  | NOT b_factor { $$ = new UnExprNode($2, OpType.Not); }
		  ;

b_factor: BVAL { $$ = new BoolNode($1); }
		| relation { $$ = $1; }
		;

relation: expr GT expr { $$ = new BinExprNode($1, $3, OpType.Gt); }
		| expr LT expr { $$ = new BinExprNode($1, $3, OpType.Lt); }
		| expr LET expr { $$ = new BinExprNode($1, $3, OpType.Let); }
		| expr GET expr { $$ = new BinExprNode($1, $3, OpType.Get); }
		| expr EQ expr { $$ = new BinExprNode($1, $3, OpType.Eq); }
		| expr NEQ expr { $$ = new BinExprNode($1, $3, OpType.Neq); }
		| expr { $$ = $1; }
		;

expr	: expr PLUS term { $$ = new BinExprNode($1, $3, OpType.Plus); }
		| expr MINUS term { $$ = new BinExprNode($1, $3, OpType.Minus); }
		| term { $$ = $1; }
		;

term    : term MULT factor { $$ = new BinExprNode($1, $3, OpType.Mult); }
		| term DIV factor { $$ = new BinExprNode($1, $3, OpType.Div); }
		| factor { $$ = $1; }
		;

factor  : LEFT_BRACKET b_expr RIGHT_BRACKET { $$ = $2; }
		| ident  { $$ = $1 as IdNode; }
		| fun_call { $$ = $1 as FunCallNode; }
		| INUM { $$ = new IntNumNode($1); }
		| DNUM { $$ = new DoubleNumNode($1); }
		;

block	: BEGIN	stlist END { $$ = $2; }
		;

cycle	: CYCLE b_expr statement { $$ = new CycleNode($2, $3); }
		;

return  : RETURN b_expr { $$ = new ReturnNode($2); }
		| RETURN	    { $$ = new ReturnNode(); }
		;
%%

